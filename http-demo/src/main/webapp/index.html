<html>
<!-- le contenu de la page initiale est dans le body. Le body contient trois liens qui pointent vers des fonctions cas1, cas 2, cas 3 (la fonction cas3 est découpée en trois sous-fonction cas3_1, cas3_2 et cas3_3) -->
<head>
	<script>
	var httpRequest ;
	
		function cas1(url) {
			dynamicContent.src="";
			content="Avec cette méthode, on envoit une requête http mais on ne traite pas la réponse. C'est le navigateur qui va recevoir la réponse et la traiter (dans notre cas, affichage dans un nouvel onglet)";
			comment.innerHTML = content;
			window.open(url);
		}
		
		function cas2(url) {
			dynamicContent.src="";
			var content="Cette méthode est identique à la précédente, on envoit une requête http en ne traitant pas la réponse. C'est le navigateur qui va recevoir la réponse et la traiter (dans notre cas, affichage dans une section de la page particulière appelée iframe qu'on a préalablement définie)";
			content+='<br><i>&lt;iframe id="dynamicContent" src="html/hello.html" style=" border-width: 0px;"&gt;&lt;/iframe&gt;</i>';
			comment.innerHTML = content;
			dynamicContent.src="html/hello.html"
			dynamicContent.style=" border-width: 2px;"
		}
		
		function cas3_1(url) {
			
			//Etape1
			dynamicContent.src="";
			dynamicContent.style=" border-width: 0px;"
			
			var content="Cette méthode est distincte de la précédente, nous envoyons une requête http mais nous traiterons nous même la réponse.";			
			content+= "<br><h2>Etape 1: Instanciation de l'objet Http: </h2>"; 
			content+="<br><br> <i>var httpRequest = new XMLHttpRequest();";
			content+="<br> httpRequest.open(\"GET\", \"helloServlet\", true);</i>";
			content+="<br><br> Cet objet existera tout le cycle de vie de la requete. "
			content+="<br>A ce stade la requete n'est pas encore envoy&eacute;e et aucune fonction de callback n'est associée à la réponse.";
			content+="<br><a href='#' onclick='cas3_2();return false;'> Suite...</a>";
			comment.innerHTML = content;
			
			 httpRequest = new XMLHttpRequest();
			httpRequest.open("GET", "helloServlet", true);	

		}
		
		function cas3_2() {
			
			var content = "<h2>Etape 2: Traitement du retour </h2>"; 
			content+= "<br> On assigne a l'objet httpRequest la fonction de callback a appeler lorsque la requete changera d'etat. Dans notre cas nous allons passer par les états 2,3 et 4 et nous afficherons le statut et le contenu de la r&eacute;ponse si celle-ci est au statut 200."; 
			content+="<br><br><i> httpRequest.onreadystatechange = callbackFunction;</i>";
			content+="<br><br>L'etat 4, signifie reponse de la requete integralement recue.";
			content+="<br><a href='#' onclick='cas3_3();return false;'> Suite...</a>";
			comment.innerHTML = content;
			
			httpRequest.onreadystatechange = function() {
				try {
					
					alert("la requete est passee au statut " + httpRequest.readyState);
					if (httpRequest.readyState == XMLHttpRequest.DONE) {
						if (httpRequest.status == 200) {
							alert('elle est au statut 200 !, on affiche le résultat : ' + httpRequest.response);
							content = "Et voilà elle a été traitée !"
							content += "<br><br> Maintenant, vous devez vous questionner sur où et quand utiliser ces différents types de requêtes http ?"
							content += "<br> C'est très simple, le premier cas se produit lorsqu'on souhaite naviguer vers une nouvelle page, elle permet le chargement de la page principale."
							content += "<br> Le second cas est utilisé pour le chargement de l'ensemble des données statiques de la page (javascript, css, images...)"
							content += "<br> Le troisième cas est utilisé pour le chargement de l'ensemble des données dynamiques de la page :  POST des données à mettre à jour, GET des données à afficher ...."
							content += "<br> Le troisième cas est utilisé pour le chargement de l'ensemble des données dynamiques de la page :  POST des données à mettre à jour, GET des données à afficher ...."
							content += "<br> Le front-end est donc un client HTTP d'un back-end qui est chargé via des requêtes aux méthodes GET, PUT, POST, DELETE d'exécuter des actions sur les données de la base de données en appliquant au besoin des traitements métiers."
																																	
							comment.innerHTML = content
														
						} else {
							alert('elle est au statut ' + httpRequest.status + "!");
						}
							
					}
				} catch (exception) {
					console.error("exception.message");

				}
			};
		}

		function cas3_3() {
			var content = "<h2>Etape 3: Envoi de la requête </h2>"; 
			content+= "<br>On demande l'envoi de la requete."; 
			content+="<br><br> <i>httpRequest.send();</i>";
			content+="<br><br> A ce stade, la requete apparait comme &eacute;mise dans le navigateur mais n'est pas encore traitee par le serveur.";
			content+=" Nous allons attendre quelques secondes le temps qu'elle soit traitée.";
			comment.innerHTML = content;
			
			try {
				httpRequest.send();
			} catch (exception) {
				console.error("error" + exception.message);
			}	
		}
		

		
	
	</script>
</head>


<body>

	<div>
		<h2>HTTP Demo</h2>
	</div>
	
	<p> Http (hyper-text trasnfer protocol) est un protocole de transfert de données. Il s'agit d'un protocole capable de transférer toutes données assimilables à du texte (html, css, xml ...) mais aussi  des images, du binaire etc.
	
	<p>	Le transfert est réalisé entre un client et un serveur : le client émet la requête, le serveur fournit la réponse. </p>
	
	<p> Voici un example de transfert de données http entre un client (outil curl) et le serveur tomcat d'eclipse:
		<br> 	<br> 
	<img src="img/Capture.PNG"/>
	</p>
	
	<p>
	<br> La première partie de l'échange concerne la connexion au serveur. Celle-ci est gérée par le protocole TCP (transmission control protocol). 
	<br> Ce protocole est chargé de s'assurer que le serveur adressé par la requête http existe et accepte la connexion.
	<br> Si c'est le cas, le client va envoyer le contenu de la requête http.
	</p>
	
	Une requête http est constituée d'un HEADER et d'un BODY.
	<br> Le header contient des informations sur la nature de la requête HTTP. Le body contient des données.
	<br><br> Le header le plus important est la méthode  de la requête, celle-ci peut-être : 
	<li> GET: je souhaite obtenir des données
	<li> POST: je souhaite t'envoyer des données
	<li> PUT: je souhaite déposer des données
	<li> DELETE: je souhaite effacer des données (il y en a d'autres mais rarement utilisée)
	
	<p> En paramètre  de la méthode on donne le chemin de la méthode : où est ce que je souhaite obtenir, envoyer, déposer des données. </p>
		
	<p> Dans notre cas, le client curl a écrit ces headers :
	<li> GET (je souhaite obtenir des données ) au chemin /http-demo/helloServlet.
	<li> Host (à quel serveur je m'adresse) localhost:48080.
	<li> User-agent: quel type de client je suis (curl, firefox...)
	<li> Accept : quel format de données j'accepte en retour (ici tout !)	
	<br><br> Le body étant vide n'apprait pas: en effet avec la méthode GET,  il n'y a aucune données à transmettre. La méthode POST, elle, nécessite la présence de données dans le body.
	</p>
	
	<p> Une réponse est constituée par le serveur et contient également un HEADER et un BODY. 
	<p> Dans notre cas, le serveur a écrit ces headers :
	<li> HTTP1/1 200 : j'ai reçu une requête HTTP à la norme 1.1 et le code retour de mon traitement est 200 : (code retour 200 = tout est ok)
	<li> Content-length:21 : il y a 21 caractères dans le BODY
	<li> Date: Tue, 14 Apr 2020 15:48:14 GMT : je te donne l'heure de traitement
	<br><br> Le body est constitué des 21 caractères suivants : Hello Sam et Thomas
	</p>
	
	<p> En résumé, Http est un protocole d'échange de données entre un serveur et un client : le client émet des requêtes et le serveur fournit des réponses.
	<br> Les requêtes et les réponses sont constituées d'HEADERs et de BODYs. Les HEADERS apportent des indications (méthode, code retour, format), les BODYS contiennent les données.
	<br> Les BODYS peuvent être absents s'il n'y a pas de données à transmettre.
	<br> les requêtes ont une méthode (GET, POST, DELETE, PUT) et un chemin. Le serveur traite la méthode au chemin donné et adresse la réponse avec un code retour 200.
	<br> S'il ne trouve pas le chemin, il renverra le code retour 404. Si la méthode est refusée, il renverra 405. Il y a quantité d'autres codes erreur.
	<br> Serveur et client sont des rôles : un serveur peut-être client d'un autre serveur. </br>
	
	</p>

	<h4>Et le web dans tout çà ?</h4>	
	
	<p> Voici trois cas de figures d'utilisation des requêtes http depuis une page web: 
		  <li>cas 1 : on demande au navigateur d'ouvrir une nouvelle page avec le contenu d'une requête http.</li>
		  <li>cas 2 : on demande au navigateur d'exécuter une requête http en associant son contenu à un élément précis d'une page web existante. 
		  		Cet élément peut-être une image, un iframe, un script....
		  <li>cas 3 : on demande au navigateur d'exécuter une requête http et de nous communiquer le résultat afin de le traiter nous même dans une fonction callback</li> 
	</p>
	
	<div>
		<ul>
		<!--  un lien classique en html -->
		  <li><a href="https://qwant.com" onclick="cas1(this.href);return false;">une requête http vers une nouvelle page (qwant)</a></li>
		  <li><a href="https://qwant.com" onclick="cas2(this.href);return false;">une requête http vers un élément de ma page (un iframe) </a></li> 
		  <li><a href="#" onclick="cas3_1(this.href);return false;">une requête http vers une fonction callback de ma page</a></li> 
		</ul>
	</div>

	<div id="comment">
	</div>		
	<iframe id="dynamicContent" src="" style=" border-width: 0px;">
	</iframe>
	
</body>

</html>
